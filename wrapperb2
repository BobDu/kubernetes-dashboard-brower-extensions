#!/bin/bash
# Loop forever, to deal with chrome.runtime.connectNative
# xxxx{"command": ""}
n=0
cmd=""

rm -f debug1.txt
rm -f debug2.txt
rm -f debug3.txt
rm -f debug4.txt

while IFS= read -r -n1 c; do
    # Read the first message
    # Assuming that the message ALWAYS ends with a },
    # with no }s in the string. Adopt this piece of code if needed.
    echo "$c" >> debug1.txt
    if [ ${n} -gt 15 ] ; then
        if [ "$c" == '"' ] ; then
            break
        fi
        cmd+=${c}
    fi
    n=$((n+1))
done

echo ${cmd} > debug2.txt

message=$(>&2 ${cmd} 2>&1)

#echo $? > d.txt

echo "${message}" > debug3.txt
# Calculate the byte size of the string.
# NOTE: This assumes that byte length is identical to the string length!
# Do not use multibyte (unicode) characters, escape them instead, e.g.
# message='"Some unicode character:\u1234"'
messagelen=${#message}

# Convert to an integer in native byte order.
# If you see an error message in Chrome's stdout with
# "Native Messaging host tried sending a message that is ... bytes long.",
# then just swap the order, i.e. messagelen1 <-> messagelen4 and
# messagelen2 <-> messagelen3
messagelen1=$(( ($messagelen      ) & 0xFF ))
messagelen2=$(( ($messagelen >>  8) & 0xFF ))
messagelen3=$(( ($messagelen >> 16) & 0xFF ))
messagelen4=$(( ($messagelen >> 24) & 0xFF ))

printf "$(printf '\\x%x\\x%x\\x%x\\x%x' \
    $messagelen1 $messagelen2 $messagelen3 $messagelen4)%s" "$message" > debug4.txt

# Print the message byte length followed by the actual message.
printf "$(printf '\\x%x\\x%x\\x%x\\x%x' \
    $messagelen1 $messagelen2 $messagelen3 $messagelen4)%s" "$message"
